diff --git a/bin/crystal b/bin/crystal
index c901d9b37..c44a90e20 100755
--- a/bin/crystal
+++ b/bin/crystal
@@ -141,7 +141,7 @@ CRYSTAL_DIR="$CRYSTAL_ROOT/.build"
 export CRYSTAL_PATH=$CRYSTAL_ROOT/src:lib
 export CRYSTAL_HAS_WRAPPER=true
 
-if [ -x "$CRYSTAL_DIR/crystal" ]; then
+if [ -x "$CRYSTAL_DIR/crystal" ] && false; then
   __warning_msg "Using compiled compiler at \`.build/crystal'"
   exec "$CRYSTAL_DIR/crystal" "$@"
 elif ! command -v crystal > /dev/null; then
@@ -151,5 +151,5 @@ elif [ "$(command -v crystal)" = "$SCRIPT_PATH" ] || [ "$(command -v crystal)" =
   export PATH="$(remove_path_item "$(remove_path_item "$PATH" "$SCRIPT_ROOT")" "bin")"
   exec "$SCRIPT_PATH" "$@"
 else
-  exec crystal "$@"
+  exec /usr/bin/crystal "$@"
 fi
diff --git a/src/compiler/crystal/codegen/codegen.cr b/src/compiler/crystal/codegen/codegen.cr
index c40b58ab1..995b76ed9 100644
--- a/src/compiler/crystal/codegen/codegen.cr
+++ b/src/compiler/crystal/codegen/codegen.cr
@@ -13,6 +13,8 @@ module Crystal
   MALLOC_ATOMIC_NAME  = "__crystal_malloc_atomic64"
   REALLOC_NAME        = "__crystal_realloc64"
   GET_EXCEPTION_NAME  = "__crystal_get_exception"
+  MALLOC_OFFSETS_NAME = "__crystal_malloc_type_offsets"
+  MALLOC_SIZE_NAME    = "__crystal_malloc_type_size"
   ONCE_INIT           = "__crystal_once_init"
   ONCE                = "__crystal_once"
 
@@ -164,6 +166,12 @@ module Crystal
     @main_builder : CrystalLLVMBuilder
     @call_location : Location?
 
+    @malloc_offset_fun : LLVM::Function
+    @malloc_size_fun : LLVM::Function
+    @malloc_types : Set(Type)
+
+    @generate_freestanding = false
+
     def initialize(@program : Program, @node : ASTNode, single_module = false, @debug = Debug::Default)
       @single_module = !!single_module
       @abi = @program.target_machine.abi
@@ -178,6 +186,10 @@ module Crystal
       ret_type = @llvm_typer.llvm_return_type(@main_ret_type)
       @main = @llvm_mod.functions.add(MAIN_NAME, [llvm_context.int32, llvm_context.void_pointer.pointer], ret_type)
 
+      @malloc_offset_fun = @llvm_mod.functions.add(MALLOC_OFFSETS_NAME, [llvm_context.int32], llvm_context.int32)
+      @malloc_size_fun = @llvm_mod.functions.add(MALLOC_SIZE_NAME, [llvm_context.int32], llvm_context.int32)
+      @malloc_types = Set(Type).new
+
       if @program.has_flag? "windows"
         @personality_name = "__CxxFrameHandler3"
 
@@ -243,7 +255,8 @@ module Crystal
       # to avoid some memory being allocated with plain malloc.
       codgen_well_known_functions @node
 
-      initialize_argv_and_argc
+      @generate_freestanding = ENV["FREESTANDING"]? == "1"
+      initialize_argv_and_argc unless @generate_freestanding
 
       if @debug.line_numbers?
         set_current_debug_location Location.new(@program.filename || "(no name)", 1, 1)
@@ -345,6 +358,88 @@ module Crystal
         codegen_fun node.real_name, node.external, @program, is_exported_fun: true
       end
 
+      # generate malloc types
+      # puts @malloc_types
+      in_main do
+        if (func = @malloc_offset_fun)
+          context.fun = func
+          context.fun.linkage = LLVM::Linkage::Internal
+
+          block = func.basic_blocks.append "entry"
+          position_at_end block
+
+          with_cloned_context do
+            arg = func.params[0]
+
+            current_block = insert_block
+
+            cases = {} of LLVM::Value => LLVM::BasicBlock
+            @malloc_types.each do |type|
+              block = new_block type.to_s
+
+              offsets = BitArray.new 32
+              unless type.packed?
+                ivars = type.all_instance_vars
+                struct_type = llvm_struct_type(type)
+                # puts "#{type} (#{type_id(type)})"
+                ivars.each_with_index do |(name, ivar), idx|
+                  if ivar.type.has_inner_pointers?
+                    offset = @program.instance_offset_of(type.sizeof_type, idx)
+                    bit = offset // (@program.codegen_target.pointer_bit_width // 8)
+                    offsets[bit] = true
+                    # puts " + #{name}, #{ivar.type}, #{offset}"
+                  else
+                    # puts " - #{name}, #{ivar.type}"
+                  end
+                end
+              end
+              # puts "offsets: #{offsets}"
+
+              position_at_end block
+              ret arg.type.const_int(offsets.to_slice.to_unsafe.as(UInt32*).value)
+
+              cases[type_id(type)] = block
+            end
+
+            otherwise = new_block "otherwise"
+            position_at_end otherwise
+            ret arg.type.const_int(0)
+
+            position_at_end current_block
+            builder.switch arg, otherwise, cases
+          end
+        end
+
+        if (func = @malloc_size_fun)
+          context.fun = func
+          context.fun.linkage = LLVM::Linkage::Internal
+
+          block = func.basic_blocks.append "entry"
+          position_at_end block
+
+          with_cloned_context do
+            arg = func.params[0]
+
+            current_block = insert_block
+
+            cases = {} of LLVM::Value => LLVM::BasicBlock
+            @malloc_types.each do |type|
+              block = new_block type.to_s
+              position_at_end block
+              ret arg.type.const_int(@program.instance_size_of(type))
+              cases[type_id(type)] = block
+            end
+
+            otherwise = new_block "otherwise"
+            position_at_end otherwise
+            ret arg.type.const_int(0)
+
+            position_at_end current_block
+            builder.switch arg, otherwise, cases
+          end
+        end
+      end
+
       env_dump = ENV["DUMP"]?
       case env_dump
       when Nil
@@ -1869,6 +1964,7 @@ module Crystal
       else
         if type.is_a?(InstanceVarContainer) && !type.struct? &&
            type.all_instance_vars.each_value.any? &.type.has_inner_pointers?
+          @malloc_types << type
           @last = malloc struct_type
         else
           @last = malloc_atomic struct_type
diff --git a/src/compiler/crystal/codegen/fun.cr b/src/compiler/crystal/codegen/fun.cr
index 502b03a06..759a2f749 100644
--- a/src/compiler/crystal/codegen/fun.cr
+++ b/src/compiler/crystal/codegen/fun.cr
@@ -387,6 +387,14 @@ class Crystal::CodeGenVisitor
     context.fun.add_attribute LLVM::Attribute::Naked if target_def.naked?
     context.fun.add_attribute LLVM::Attribute::NoReturn if target_def.no_returns?
 
+    if target_def.weak?
+      context.fun.linkage = LLVM::Linkage::ExternalWeak     
+    end
+    
+    unless target_def.generate_red_zone?
+      context.fun.add_attribute LLVM::Attribute::NoRedZone
+    end
+
     if target_def.no_inline?
       context.fun.add_attribute LLVM::Attribute::NoInline
       context.fun.linkage = LLVM::Linkage::External
diff --git a/src/compiler/crystal/codegen/target.cr b/src/compiler/crystal/codegen/target.cr
index b4ee5475d..e9b674678 100644
--- a/src/compiler/crystal/codegen/target.cr
+++ b/src/compiler/crystal/codegen/target.cr
@@ -105,7 +105,8 @@ class Crystal::Codegen::Target
     environment_parts.includes?("gnueabihf") || environment_parts.includes?("musleabihf")
   end
 
-  def to_target_machine(cpu = "", features = "", release = false) : LLVM::TargetMachine
+  def to_target_machine(cpu = "", features = "", release = false,
+                        code_model = LLVM::CodeModel::Default) : LLVM::TargetMachine
     case @architecture
     when "i386", "x86_64"
       LLVM.init_x86
@@ -127,7 +128,7 @@ class Crystal::Codegen::Target
     opt_level = release ? LLVM::CodeGenOptLevel::Aggressive : LLVM::CodeGenOptLevel::None
 
     target = LLVM::Target.from_triple(self.to_s)
-    target.create_target_machine(self.to_s, cpu: cpu, features: features, opt_level: opt_level).not_nil!
+    target.create_target_machine(self.to_s, cpu: cpu, features: features, opt_level: opt_level, code_model: code_model).not_nil!
   end
 
   def to_s(io : IO) : Nil
diff --git a/src/compiler/crystal/command.cr b/src/compiler/crystal/command.cr
index 333b529d6..9dcf14d6d 100644
--- a/src/compiler/crystal/command.cr
+++ b/src/compiler/crystal/command.cr
@@ -364,6 +364,26 @@ class Crystal::Command
         opts.on("--mattr CPU", "Target specific features") do |features|
           compiler.mattr = features
         end
+        opts.on("--mcmodel CPU", "Target specific code model") do |mcmodel|
+          compiler.mcmodel = case mcmodel
+            when "default"
+              LLVM::CodeModel::Default
+            when "small"
+              LLVM::CodeModel::Small
+            when "kernel"
+              LLVM::CodeModel::Kernel
+            when "medium"
+              LLVM::CodeModel::Medium
+            when "large"
+              LLVM::CodeModel::Large
+            else
+              error "--mcmodel should be one of: default, kernel, small, medium, large"
+              raise "unreachable"
+            end
+        end
+        opts.on("--mno-red-zone", "Disable generation of red zone") do 
+          compiler.generate_red_zone = false
+        end
         setup_compiler_warning_options(opts, compiler)
       end
 
diff --git a/src/compiler/crystal/compiler.cr b/src/compiler/crystal/compiler.cr
index 7b13beee3..200c77d1e 100644
--- a/src/compiler/crystal/compiler.cr
+++ b/src/compiler/crystal/compiler.cr
@@ -4,6 +4,10 @@ require "socket"
 require "colorize"
 require "digest/md5"
 
+lib LibLLVM
+  fun LLVMDeleteFunction(fn : ValueRef)
+end
+
 module Crystal
   @[Flags]
   enum Debug
@@ -84,6 +88,12 @@ module Crystal
     # If `true`, runs LLVM optimizations.
     property? release = false
 
+    # Sets the code model. Check LLVM docs to learn about this.
+    property mcmodel = LLVM::CodeModel::Default
+
+    # If `true`, generates red zone. Check LLVM docs to learn about this.
+    property? generate_red_zone = true
+
     # If `true`, generates a single LLVM module. By default
     # one LLVM module is created for each type in a program.
     property? single_module = false
@@ -201,6 +211,7 @@ module Crystal
       program.cache_dir = CacheDir.instance.directory_for(sources)
       program.codegen_target = codegen_target
       program.target_machine = target_machine
+      program.generate_red_zone = generate_red_zone?
       program.flags << "release" if release?
       program.flags << "debug" unless debug.none?
       program.flags << "static" if static?
@@ -249,7 +260,7 @@ module Crystal
 
     private def bc_flags_changed?(output_dir)
       bc_flags_changed = true
-      current_bc_flags = "#{@codegen_target}|#{@mcpu}|#{@mattr}|#{@release}|#{@link_flags}"
+      current_bc_flags = "#{@codegen_target}|#{@mcpu}|#{@mattr}|#{@release}|#{@link_flags}|#{@mcmodel}"
       bc_flags_filename = "#{output_dir}/bc_flags"
       if File.file?(bc_flags_filename)
         previous_bc_flags = File.read(bc_flags_filename).strip
@@ -306,13 +317,17 @@ module Crystal
 
       optimize llvm_mod if @release
 
+      if !ENV["FREESTANDING"]?.nil?
+        LibLLVM.LLVMDeleteFunction llvm_mod.functions["__crystal_main"].to_unsafe
+      end
+
       if emit = @emit
         unit.emit(emit, emit_base_filename || output_filename)
+      else
+        target_machine.emit_obj_to_file llvm_mod, object_name
       end
 
-      target_machine.emit_obj_to_file llvm_mod, object_name
-
-      stdout.puts linker_command(program, object_name, output_filename, nil)
+      # stdout.puts linker_command(program, object_name, output_filename, nil)
     end
 
     private def linker_command(program : Program, object_name, output_filename, output_dir)
@@ -521,7 +536,7 @@ module Crystal
     end
 
     getter(target_machine : LLVM::TargetMachine) do
-      @codegen_target.to_target_machine(@mcpu || "", @mattr || "", @release)
+      @codegen_target.to_target_machine(@mcpu || "", @mattr || "", @release, @mcmodel)
     rescue ex : ArgumentError
       stderr.print colorize("Error: ").red.bold
       stderr.print "llc: "
diff --git a/src/compiler/crystal/program.cr b/src/compiler/crystal/program.cr
index 6171ff1c0..e589de1c5 100644
--- a/src/compiler/crystal/program.cr
+++ b/src/compiler/crystal/program.cr
@@ -118,6 +118,8 @@ module Crystal
 
     property codegen_target = Config.default_target
 
+    property generate_red_zone = false
+
     # Which kind of warnings wants to be detected.
     property warnings : Warnings = Warnings::All
 
@@ -242,6 +244,7 @@ module Crystal
       types["ReturnsTwice"] = @returns_twice_annotation = AnnotationType.new self, self, "ReturnsTwice"
       types["ThreadLocal"] = @thread_local_annotation = AnnotationType.new self, self, "ThreadLocal"
       types["Deprecated"] = @deprecated_annotation = AnnotationType.new self, self, "Deprecated"
+      types["Weak"] = @weak_annotation = AnnotationType.new self, self, "Weak"
 
       define_crystal_constants
     end
@@ -463,7 +466,7 @@ module Crystal
                      packed_annotation thread_local_annotation no_inline_annotation
                      always_inline_annotation naked_annotation returns_twice_annotation
                      raises_annotation primitive_annotation call_convention_annotation
-                     flags_annotation link_annotation extern_annotation deprecated_annotation) %}
+                     flags_annotation link_annotation extern_annotation deprecated_annotation weak_annotation) %}
       def {{name.id}}
         @{{name.id}}.not_nil!
       end
diff --git a/src/compiler/crystal/semantic/ast.cr b/src/compiler/crystal/semantic/ast.cr
index 763b958e2..f5e8c6968 100644
--- a/src/compiler/crystal/semantic/ast.cr
+++ b/src/compiler/crystal/semantic/ast.cr
@@ -144,6 +144,12 @@ module Crystal
     # `true` if this def has the `@[Naked]` annotation
     property? naked = false
 
+    # `true` if this def has the @[Weak]` annotation
+    property? weak = false
+
+    # `true` if program doesn't generate red zone
+    property? generate_red_zone = false
+
     # Is this a `new` method that was expanded from an initialize?
     property? new = false
 
@@ -220,6 +226,7 @@ module Crystal
       a_def.previous = previous
       a_def.raises = raises?
       a_def.no_inline = no_inline?
+      a_def.weak = weak?
       a_def.always_inline = always_inline?
       a_def.returns_twice = returns_twice?
       a_def.naked = naked?
diff --git a/src/compiler/crystal/semantic/top_level_visitor.cr b/src/compiler/crystal/semantic/top_level_visitor.cr
index 52f7219a3..e611c1d70 100644
--- a/src/compiler/crystal/semantic/top_level_visitor.cr
+++ b/src/compiler/crystal/semantic/top_level_visitor.cr
@@ -857,6 +857,8 @@ class Crystal::TopLevelVisitor < Crystal::SemanticVisitor
       call_convention = scope.call_convention
     end
 
+    external.generate_red_zone = @program.generate_red_zone
+
     # We fill the arguments and return type in TypeDeclarationVisitor
     external.doc = node.doc
     external.call_convention = call_convention
@@ -1078,6 +1080,8 @@ class Crystal::TopLevelVisitor < Crystal::SemanticVisitor
         node.returns_twice = true
       when @program.raises_annotation
         node.raises = true
+      when @program.weak_annotation
+        node.weak = true
       when @program.deprecated_annotation
         # Check whether a DeprecatedAnnotation can be built.
         # There is no need to store it, but enforcing
